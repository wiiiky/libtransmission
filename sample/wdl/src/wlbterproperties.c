/*
 * Copyright (C) 2014-2014 Wiky L(wiiiky@yeah.net)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * this file is generated by gobj(https://github.com/wiiiky/gobj)
 */

#include "wlbterproperties.h"

enum {
	PROPERTY_TORRENT = 1,
};

G_DEFINE_TYPE(WlBterProperties, wl_bter_properties, GTK_TYPE_DIALOG);

static void wl_bter_properties_init(WlBterProperties * obj);
static void wl_bter_properties_finalize(GObject * obj);
static void wl_bter_properties_class_init(WlBterPropertiesClass * klass);
static void wl_bter_properties_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps);
static void wl_bter_properties_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps);

static void onDialogResponse(GtkDialog * dialog, gint reponseId,
							 gpointer data);
static gboolean onDialogDelete(GtkWidget * dialog, GdkEvent * event,
							   gpointer data);
static gboolean onTimeout(gpointer data);

static void startTimeout(WlBterProperties * dialog);
static void stopTimeout(WlBterProperties * dialog);

static void updateTorrentInfo(WlBterProperties * dialog);
static const gchar *getSizePhrase(guint64 size);
static const gchar *getStatePhrase(tr_torrent_activity activity);
static const gchar *getSpeedPhrase(guint64 Kbs);

enum {
	PEER_VIEW_ADDR = 0,
	PEER_VIEW_CLIENT,
	PEER_VIEW_PRO,
	PEER_VIEW_UP,
	PEER_VIEW_DOWN,
	PEER_VIEW_FLAG,
	PEER_VIEW_COUNT,
};

static void wl_bter_properties_init(WlBterProperties * obj)
{
	gtk_container_set_border_width(GTK_CONTAINER(obj), 8);
	gtk_window_set_modal(GTK_WINDOW(obj), TRUE);
	gtk_window_set_default_size(GTK_WINDOW(obj), 480, 560);
	gtk_dialog_add_button(GTK_DIALOG(obj), "Close", GTK_RESPONSE_CLOSE);
	gtk_dialog_set_default_response(GTK_DIALOG(obj), GTK_RESPONSE_CLOSE);

	GtkWidget *box = gtk_dialog_get_content_area(GTK_DIALOG(obj));
	GtkWidget *notebook = gtk_notebook_new();
	gtk_box_pack_start(GTK_BOX(box), notebook, TRUE, TRUE, 0);


	GtkWidget *infoBox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
	gtk_container_set_border_width(GTK_CONTAINER(infoBox), 5);
	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), infoBox,
							 gtk_label_new("infomation"));

	/* Activity */
	GtkWidget *label;
	label = gtk_label_new("<b>Activity</b>");
	gtk_label_set_use_markup(GTK_LABEL(label), TRUE);
	GtkWidget *activityFrame = gtk_frame_new("Activity");
	gtk_frame_set_label_widget(GTK_FRAME(activityFrame), label);
	gtk_box_pack_start(GTK_BOX(infoBox), activityFrame, FALSE, FALSE, 0);
	gtk_frame_set_shadow_type(GTK_FRAME(activityFrame), GTK_SHADOW_NONE);
	GtkWidget *activityGrid = gtk_grid_new();
	gtk_container_add(GTK_CONTAINER(activityFrame), activityGrid);
	gtk_container_set_border_width(GTK_CONTAINER(activityGrid), 8);
	gtk_widget_set_margin_left(activityGrid, 10);
	gtk_grid_set_row_spacing(GTK_GRID(activityGrid), 3);
	gtk_grid_set_column_spacing(GTK_GRID(activityGrid), 12);

	label = gtk_label_new("Torrent Size :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 0, 1, 1);
	GtkWidget *torrentSize =
		gtk_label_new("12.0 GB (100 pieces @ 256 KB)");
	gtk_widget_set_halign(torrentSize, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), torrentSize, 1, 0, 1, 1);

	label = gtk_label_new("Have :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 1, 1, 1);
	GtkWidget *haveSize = gtk_label_new("12.0 GB (100%)");
	gtk_widget_set_halign(haveSize, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), haveSize, 1, 1, 1, 1);

	label = gtk_label_new("Downloaded :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 2, 1, 1);
	GtkWidget *downloadedSize = gtk_label_new("12.0 GB");
	gtk_widget_set_halign(downloadedSize, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), downloadedSize, 1, 2, 1, 1);

	label = gtk_label_new("Uploaded :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 3, 1, 1);
	GtkWidget *uploadedSize = gtk_label_new("12.0 GB (Ratio: 1.0)");
	gtk_widget_set_halign(uploadedSize, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), uploadedSize, 1, 3, 1, 1);

	label = gtk_label_new("State :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 4, 1, 1);
	GtkWidget *stateLabel = gtk_label_new("Seeding");
	gtk_widget_set_halign(stateLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), stateLabel, 1, 4, 1, 1);

	label = gtk_label_new("Download Speed :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 5, 1, 1);
	GtkWidget *downloadSpeed = gtk_label_new("15 Kb/s");
	gtk_widget_set_halign(downloadSpeed, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), downloadSpeed, 1, 5, 1, 1);

	label = gtk_label_new("Upload Speed :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 6, 1, 1);
	GtkWidget *uploadSpeed = gtk_label_new("15 Kb/s");
	gtk_widget_set_halign(uploadSpeed, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), uploadSpeed, 1, 6, 1, 1);

	label = gtk_label_new("Error :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), label, 0, 7, 1, 1);
	GtkWidget *errorLabel = gtk_label_new("No error");
	gtk_widget_set_halign(errorLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(activityGrid), errorLabel, 1, 7, 1, 1);


	/* Details */
	label = gtk_label_new("<b>Details</b>");
	gtk_label_set_use_markup(GTK_LABEL(label), TRUE);
	GtkWidget *detailsFrame = gtk_frame_new("Details");
	gtk_frame_set_label_widget(GTK_FRAME(detailsFrame), label);
	gtk_box_pack_start(GTK_BOX(infoBox), detailsFrame, TRUE, TRUE, 0);
	gtk_frame_set_shadow_type(GTK_FRAME(detailsFrame), GTK_SHADOW_NONE);
	GtkWidget *detailsGrid = gtk_grid_new();
	gtk_container_add(GTK_CONTAINER(detailsFrame), detailsGrid);
	gtk_container_set_border_width(GTK_CONTAINER(detailsGrid), 8);
	gtk_widget_set_margin_left(detailsGrid, 10);
	gtk_grid_set_row_spacing(GTK_GRID(detailsGrid), 3);
	gtk_grid_set_column_spacing(GTK_GRID(detailsGrid), 12);

	label = gtk_label_new("Location :      ");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 0, 1, 1);
	GtkWidget *locationLabel = gtk_label_new("/home/username/Download");
	gtk_widget_set_halign(locationLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), locationLabel, 1, 0, 1, 1);

	label = gtk_label_new("Hash :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 1, 1, 1);
	GtkWidget *hashLabel =
		gtk_label_new("724bcc8a53b854daa844e6bc204b95124a1074d6");
	gtk_widget_set_halign(hashLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), hashLabel, 1, 1, 1, 1);

	label = gtk_label_new("Privacy :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 2, 1, 1);
	GtkWidget *privacyLabel = gtk_label_new("Public torrent");
	gtk_widget_set_halign(privacyLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), privacyLabel, 1, 2, 1, 1);

	label = gtk_label_new("Origin :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 3, 1, 1);
	GtkWidget *originLabel = gtk_label_new("Created on 17 Dec 2013");
	gtk_widget_set_halign(originLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), originLabel, 1, 3, 1, 1);

	label = gtk_label_new("Creator :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 4, 1, 1);
	GtkWidget *creatorLabel = gtk_label_new("Wiky");
	gtk_widget_set_halign(creatorLabel, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), creatorLabel, 1, 4, 1, 1);

	label = gtk_label_new("Comment :");
	gtk_widget_set_halign(label, GTK_ALIGN_START);
	gtk_grid_attach(GTK_GRID(detailsGrid), label, 0, 5, 1, 1);
	GtkWidget *commentView = gtk_text_view_new();
	gtk_text_view_set_editable(GTK_TEXT_VIEW(commentView), FALSE);
	gtk_grid_attach(GTK_GRID(detailsGrid), commentView, 1, 5, 1, 1);

	/* Peers */
	GtkWidget *peerBox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
	gtk_container_set_border_width(GTK_CONTAINER(peerBox), 5);
	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), peerBox,
							 gtk_label_new("Peers"));

	GtkWidget *scrolledWindow = gtk_scrolled_window_new(NULL, NULL);
	gtk_box_pack_start(GTK_BOX(peerBox), scrolledWindow, TRUE, TRUE, 0);
	GtkListStore *listStore =
		gtk_list_store_new(PEER_VIEW_COUNT, G_TYPE_STRING, G_TYPE_STRING,
						   G_TYPE_STRING,
						   G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
	GtkWidget *peerView =
		gtk_tree_view_new_with_model(GTK_TREE_MODEL(listStore));
	gtk_container_add(GTK_CONTAINER(scrolledWindow), peerView);
	GtkCellRenderer *renderer = gtk_cell_renderer_text_new();
	GtkTreeViewColumn *col =
		gtk_tree_view_column_new_with_attributes("Address",
												 renderer,
												 "text", PEER_VIEW_ADDR,
												 NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);

	renderer = gtk_cell_renderer_text_new();
	col =
		gtk_tree_view_column_new_with_attributes("Client", renderer,
												 "text", PEER_VIEW_CLIENT,
												 NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);
	renderer = gtk_cell_renderer_text_new();
	col =
		gtk_tree_view_column_new_with_attributes("Flag", renderer, "text",
												 PEER_VIEW_FLAG, NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);
	renderer = gtk_cell_renderer_text_new();
	col =
		gtk_tree_view_column_new_with_attributes("%", renderer, "text",
												 PEER_VIEW_PRO, NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);
	renderer = gtk_cell_renderer_text_new();
	col =
		gtk_tree_view_column_new_with_attributes("Up", renderer, "text",
												 PEER_VIEW_UP, NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);
	renderer = gtk_cell_renderer_text_new();
	col =
		gtk_tree_view_column_new_with_attributes("Down", renderer, "text",
												 PEER_VIEW_DOWN, NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(peerView), col);

	gtk_widget_show_all(box);

	obj->torrentSize = torrentSize;
	obj->haveSize = haveSize;
	obj->downloadedSize = downloadedSize;
	obj->uploadedSize = uploadedSize;
	obj->stateLabel = stateLabel;
	obj->downloadSpeed = downloadSpeed;
	obj->uploadSpeed = uploadSpeed;
	obj->locationLabel = locationLabel;
	obj->hashLabel = hashLabel;
	obj->privacyLabel = privacyLabel;
	obj->originLabel = originLabel;
	obj->commentView = commentView;
	obj->creatorLabel = creatorLabel;
	obj->errorLabel = errorLabel;
	obj->peerView = peerView;
	obj->peerStore = listStore;
	obj->torrent = NULL;
	obj->timeout = 0;

	/* signals */
	g_signal_connect(G_OBJECT(obj), "response",
					 G_CALLBACK(onDialogResponse), NULL);
	g_signal_connect(G_OBJECT(obj), "delete-event",
					 G_CALLBACK(onDialogDelete), NULL);
}

static void wl_bter_properties_finalize(GObject * obj)
{
}

static void wl_bter_properties_class_init(WlBterPropertiesClass * klass)
{
	GObjectClass *objClass = G_OBJECT_CLASS(klass);
	objClass->get_property = wl_bter_properties_getter;
	objClass->set_property = wl_bter_properties_setter;
	objClass->finalize = wl_bter_properties_finalize;

	GParamSpec *ps;
	/* properties */
	ps = g_param_spec_pointer("torrent",
							  "tr_torrent",
							  "Tr Torrent",
							  G_PARAM_READABLE | G_PARAM_WRITABLE |
							  G_PARAM_CONSTRUCT);
	g_object_class_install_property(objClass, PROPERTY_TORRENT, ps);
}

static void wl_bter_properties_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps)
{
	WlBterProperties *obj = WL_BTER_PROPERTIES(object);
	switch (property_id) {
	case PROPERTY_TORRENT:
		g_value_set_pointer(value, obj->torrent);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static void wl_bter_properties_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps)
{
	WlBterProperties *obj = WL_BTER_PROPERTIES(object);
	switch (property_id) {
	case PROPERTY_TORRENT:
		obj->torrent = g_value_get_pointer(value);
		updateTorrentInfo(obj);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static void onDialogResponse(GtkDialog * dialog, gint reponseId,
							 gpointer data)
{
	gtk_widget_hide(GTK_WIDGET(dialog));
	stopTimeout(WL_BTER_PROPERTIES(dialog));
}

static gboolean onDialogDelete(GtkWidget * dialog, GdkEvent * event,
							   gpointer data)
{
	gtk_dialog_response(GTK_DIALOG(dialog), GTK_RESPONSE_CLOSE);
	return TRUE;
}

static gboolean onTimeout(gpointer data)
{
	WlBterProperties *dialog = data;
	if (dialog->torrent == NULL) {
		g_warning("torrent is NULL!!!");
		return FALSE;
	}

	const tr_stat *stat = tr_torrentStatCached(dialog->torrent);

	/* 下载和上传速度 */
	gtk_label_set_text(GTK_LABEL(dialog->downloadSpeed),
					   getSpeedPhrase(stat->pieceDownloadSpeed_KBps));
	gtk_label_set_text(GTK_LABEL(dialog->uploadSpeed),
					   getSpeedPhrase(stat->pieceUploadSpeed_KBps));
	/* 已下载数据 */
	gtk_label_set_text(GTK_LABEL(dialog->downloadedSize),
					   getSizePhrase(stat->haveUnchecked +
									 stat->haveValid));
	/* 已经有的数据(已验证) */
	gchar *have =
		g_strdup_printf("%s (%.1f%%)", getSizePhrase(stat->haveValid),
						stat->percentDone * 100.0);
	gtk_label_set_text(GTK_LABEL(dialog->haveSize), have);
	/* 上传的数据 */
	gtk_label_set_text(GTK_LABEL(dialog->uploadedSize),
					   getSizePhrase(stat->uploadedEver));
	/* 当前状态 */
	gtk_label_set_text(GTK_LABEL(dialog->stateLabel),
					   getStatePhrase(stat->activity));
	g_free(have);

	/* peers 8秒更新一次 */
#define CYCLE   (8)
	static gint five = 0;
	if (five <= 0) {
		five = CYCLE;
		gint peerCount = 0, i;
		tr_peer_stat *peerStats =
			tr_torrentPeers(dialog->torrent, &peerCount);
		GtkListStore *listStore = dialog->peerStore;
		gtk_list_store_clear(listStore);
		for (i = 0; i < peerCount; i++) {
			GtkTreeIter iter;
			gtk_list_store_append(listStore, &iter);
			gchar progress[10];
			g_snprintf(progress, 10, "%.1f%%",
					   peerStats[i].progress * 100.0);
			gchar up[10];
			g_snprintf(up, 10, "%s",
					   getSpeedPhrase(peerStats[i].rateToPeer_KBps));
			gtk_list_store_set(listStore, &iter, PEER_VIEW_ADDR,
							   peerStats[i].addr, PEER_VIEW_CLIENT,
							   peerStats[i].client, PEER_VIEW_PRO,
							   progress, PEER_VIEW_UP, up, PEER_VIEW_DOWN,
							   getSpeedPhrase(peerStats[i].
											  rateToClient_KBps),
							   PEER_VIEW_FLAG, peerStats[i].flagStr, -1);
		}
		tr_torrentPeersFree(peerStats, peerCount);
	} else
		five--;
#undef CYCLE
	return TRUE;
}

static void startTimeout(WlBterProperties * dialog)
{
	dialog->timeout = g_timeout_add(1000, onTimeout, dialog);
}

static void stopTimeout(WlBterProperties * dialog)
{
	g_source_remove(dialog->timeout);
	dialog->timeout = 0;
}

static void updateTorrentInfo(WlBterProperties * dialog)
{
	if (dialog->torrent == NULL)
		return;

	const tr_info *info = tr_torrentInfo(dialog->torrent);
	gtk_window_set_title(GTK_WINDOW(dialog), info->originalName);
	/* location */
	gtk_label_set_text(GTK_LABEL(dialog->locationLabel),
					   tr_torrentGetDownloadDir(dialog->torrent));
	/* Comment */
	GtkTextBuffer *buffer = gtk_text_buffer_new(NULL);
	gtk_text_buffer_set_text(buffer,
							 info->comment == NULL ? "" : info->comment,
							 -1);
	gtk_text_view_set_buffer(GTK_TEXT_VIEW(dialog->commentView), buffer);
	/* Hash */
	gtk_label_set_text(GTK_LABEL(dialog->hashLabel), info->hashString);
	/* privacy */
	gtk_label_set_text(GTK_LABEL(dialog->privacyLabel),
					   info->
					   isPrivate ? "Private torrent" : "Public torrent");
	/* creator */
	gtk_label_set_text(GTK_LABEL(dialog->creatorLabel),
					   info->creator ? info->creator : "");
	/* origin */
	GDateTime *dt = g_date_time_new_from_unix_utc(info->dateCreated);
	gchar *format = g_date_time_format(dt, "Created on %d %m %Y");
	gtk_label_set_text(GTK_LABEL(dialog->originLabel), format);
	g_free(format);

	/*****/
	const tr_stat *stat = tr_torrentStatCached(dialog->torrent);
	gtk_label_set_text(GTK_LABEL(dialog->errorLabel),
					   stat->error !=
					   TR_STAT_OK ? stat->errorString : "No error");
	/* torrent Size */
	gchar *pieceSize = g_strdup(getSizePhrase(info->pieceSize));
	gchar *total =
		g_strdup_printf("%s (%d pieces @ %s)",
						getSizePhrase(info->totalSize), info->pieceCount,
						pieceSize);
	g_free(pieceSize);
	gtk_label_set_text(GTK_LABEL(dialog->torrentSize), total);
	g_free(total);
	/* have */
	gchar *have =
		g_strdup_printf("%s (%.1f%%)",
						getSizePhrase(stat->haveValid +
									  stat->haveUnchecked),
						stat->percentDone);
	gtk_label_set_text(GTK_LABEL(dialog->haveSize), have);
	g_free(have);
	/* downloaded */
	gtk_label_set_text(GTK_LABEL(dialog->downloadedSize),
					   getSizePhrase(stat->sizeWhenDone -
									 stat->leftUntilDone));
	/* uploaded */
	gtk_label_set_text(GTK_LABEL(dialog->uploadedSize),
					   getSizePhrase(stat->uploadedEver));
	/* state */
	gtk_label_set_text(GTK_LABEL(dialog->stateLabel),
					   getStatePhrase(stat->activity));

	/* speed */
	gtk_label_set_text(GTK_LABEL(dialog->downloadSpeed), "");
	gtk_label_set_text(GTK_LABEL(dialog->uploadSpeed), "");
}

/* 将字节大小转化为可读的字符串形式 */
static const gchar *getSizePhrase(guint64 size)
{
	static gchar string[20];
	if (size >= 1000 * 1000 * 1000) {	/* GB */
		g_snprintf(string, 20, "%.1f GB",
				   (gdouble) size / (1000.0 * 1000.0 * 1000.0));
	} else if (size >= 1000 * 1000) {
		g_snprintf(string, 20, "%.1f MB",
				   (gdouble) size / (1000.0 * 1000.0));
	} else if (size >= 1000) {
		g_snprintf(string, 20, "%.1f KB", (gdouble) size / (1000.0));
	} else {
		g_snprintf(string, 20, "%lu B", size);
	}
	return string;
}

static const gchar *getSpeedPhrase(guint64 Kbs)
{
	static gchar label[20];
	if (Kbs > 1000) {			/* mB/s */
		g_snprintf(label, 20, "%.2f mB/s", Kbs / 1000);
	} else if (Kbs < 1) {
		g_snprintf(label, 20, "%.0f B/s", Kbs * 1000);
	} else {
		g_snprintf(label, 20, "%.2f kB/s", Kbs);
	}
	return label;
}

static const gchar *getStatePhrase(tr_torrent_activity activity)
{
	switch (activity) {
	case TR_STATUS_SEED:
		return "Seeding";
		break;
	case TR_STATUS_SEED_WAIT:
		return "Seeding wait";
		break;
	case TR_STATUS_CHECK:
		return "Checking";
		break;
	case TR_STATUS_CHECK_WAIT:
		return "Checking wait";
		break;
	case TR_STATUS_DOWNLOAD:
		return "Downloading";
		break;
	case TR_STATUS_DOWNLOAD_WAIT:
		return "Downloading wait";
		break;
	case TR_STATUS_STOPPED:
		return "Stopped";
		break;
	default:
		return "Unknown";
		break;
	}
	return "Unknown";
}

/**************************************************
 * PUBILC
 **************************************************/
GtkWidget *wl_bter_properties_new(void)
{
	GtkWidget *dialog =
		(GtkWidget *) g_object_new(WL_TYPE_BTER_PROPERTIES, NULL);

	return dialog;
}

GtkWidget *wl_bter_properties_new_with_torrent(tr_torrent * torrent)
{
	GtkWidget *dialog = (GtkWidget *) g_object_new(WL_TYPE_BTER_PROPERTIES,
												   "torrent", torrent,
												   NULL);

	return dialog;
}

void wl_bter_properties_set_torrent(WlBterProperties * dialog,
									tr_torrent * torrent)
{
	g_return_if_fail(WL_IS_BTER_PROPERTIES(dialog));
	g_object_set(G_OBJECT(dialog), "torrent", torrent, NULL);
}

void wl_bter_properties_run(WlBterProperties * dialog)
{
	g_return_if_fail(WL_IS_BTER_PROPERTIES(dialog));

	startTimeout(dialog);
	gtk_dialog_run(GTK_DIALOG(dialog));
}
