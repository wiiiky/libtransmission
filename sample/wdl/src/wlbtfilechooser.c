/*
 * Copyright (C) 2014-2014 Wiky L(wiiiky@yeah.net)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * this file is generated by gobj(https://github.com/wiiiky/gobj)
 */

#include "wlbtfilechooser.h"
#include <string.h>

enum {
	WL_BT_FILE_CHOOSER_PROPERTY_TORRENT = 1,
	WL_BT_FILE_CHOOSER_PROPERTY_CTOR,
	WL_BT_FILE_CHOOSER_PROPERTY_PATH,
};


/* UI各部分的名字 */
#define UI_WINDOW	"torrent_window"
#define UI_TORRENT   "torrent_chooser"
#define UI_FOLDER   "folder_chooser"
#define UI_TREEVIEW "file_view"
#define UI_SPACE	"space_label"
#define UI_TREESTORE	"file_tree"
#define UI_OPEN "open_button"
#define UI_CANCEL   "cancel_button"
#define UI_TRASH	"trash_button"
#define UI_START	"start_button"

/* 常用图标的名字 */
#define ICON_FOLDER "folder"


#define TREEVIEW_ICON_SIZE  16

#define TREE_STORE_COL_ICON (0)
#define TREE_STORE_COL_NAME (1)
#define TREE_STORE_COL_SIZE (2)
#define TREE_STORE_COL_DL   (3)
#define TREE_STORE_COL_INDEX	(4)
#define TREE_STORE_COL_INC  (5)
#define TREE_STORE_COL_LENGTH   (6)

G_DEFINE_TYPE(WlBtFileChooser, wl_bt_file_chooser, GTK_TYPE_BUILDER);

static void wl_bt_file_chooser_init(WlBtFileChooser * obj);
static void wl_bt_file_chooser_finalize(GObject * obj);
static void wl_bt_file_chooser_class_init(WlBtFileChooserClass * klass);
static void wl_bt_file_chooser_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps);
static void wl_bt_file_chooser_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps);
static inline gboolean wl_bt_file_chooser_update(WlBtFileChooser *
												 chooser);
/* 将torrent文件移动到回收站? */
static inline gboolean wl_bt_file_chooser_torrent_trash(WlBtFileChooser *
														chooser);
static gboolean wl_bt_file_chooser_close(GtkWidget * widget,
										 GdkEvent * event, gpointer data);
static void wl_bt_file_chooser_open(GtkWidget * button, gpointer data);
static void wl_bt_file_chooser_cancel(GtkWidget * button, gpointer data);
/* 选择的种子文件改变 */
static void wl_bt_file_chooser_set(GtkFileChooserButton * button,
								   gpointer data);

static inline void wl_bt_file_chooser_show_invalid(GtkWidget * window,
												   const gchar * name);
static inline void wl_bt_file_chooser_show_duplicate(GtkWidget * window,
													 const gchar * name);

void cellrenderertoggle_toggled_cb(GtkCellRendererToggle * cell,
								   gchar * path_str, gpointer data);
/* 设置所有子文件的下载状态 */
static void wdl_set_all_child_dl(GtkTreeModel * model, GtkTreeIter * iter,
								 gboolean flag);

/* 将字节大小转化为可读的字符串形式 */
static const gchar *make_size_readable(guint64 size);

/* 将图标转化为GdkPixbuf形式 */
static GdkPixbuf *get_pixbuf_from_icon(GtkIconTheme * icon_theme,
									   GThemedIcon * icon, gint size);
static GdkPixbuf *get_pixbuf_from_icon_name(const gchar * name, gint size);

/* 移动到回收站 */
static void move_file_to_trash(const gchar * file);

static void wl_bt_file_chooser_init(WlBtFileChooser * chooser)
{
	if (!gtk_builder_add_from_file(GTK_BUILDER(chooser), UI_FILE, NULL)) {
		/* 载入失败退出程序 */
		g_error("Fail to load " UI_FILE);
	}
	gtk_builder_connect_signals(GTK_BUILDER(chooser), NULL);

	chooser->window =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_WINDOW);

	chooser->default_path =
		g_strdup(g_get_user_special_dir(G_USER_DIRECTORY_DOWNLOAD));
	chooser->torrent = NULL;
	chooser->ctor = NULL;
	chooser->loop = NULL;
}

static void wl_bt_file_chooser_finalize(GObject * obj)
{
	WlBtFileChooser *chooser = WL_BT_FILE_CHOOSER(obj);
	g_free(chooser->default_path);
}

static void wl_bt_file_chooser_class_init(WlBtFileChooserClass * klass)
{
	GObjectClass *obj_class = G_OBJECT_CLASS(klass);
	obj_class->get_property = wl_bt_file_chooser_getter;
	obj_class->set_property = wl_bt_file_chooser_setter;
	obj_class->finalize = wl_bt_file_chooser_finalize;

	GParamSpec *ps;
	/* properties */
	ps = g_param_spec_pointer("torrent",
							  "BT torrent",
							  "BT Torrent",
							  G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_TORRENT,
									ps);

	ps = g_param_spec_pointer("ctor",
							  "torrent constructor",
							  "Torrent Constructor",
							  G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_CTOR, ps);

	ps = g_param_spec_string("path",
							 "default download path",
							 "Default Download Path",
							 NULL, G_PARAM_READABLE | G_PARAM_WRITABLE);
	g_object_class_install_property(obj_class,
									WL_BT_FILE_CHOOSER_PROPERTY_PATH, ps);
}

static void wl_bt_file_chooser_getter(GObject * object, guint property_id,
									  GValue * value, GParamSpec * ps)
{
	WlBtFileChooser *obj = WL_BT_FILE_CHOOSER(object);
	switch (property_id) {
	case WL_BT_FILE_CHOOSER_PROPERTY_TORRENT:
		g_value_set_pointer(value, obj->torrent);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_CTOR:
		g_value_set_pointer(value, obj->ctor);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_PATH:
		g_value_set_string(value, obj->default_path);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static void wl_bt_file_chooser_setter(GObject * object, guint property_id,
									  const GValue * value,
									  GParamSpec * ps)
{
	WlBtFileChooser *obj = WL_BT_FILE_CHOOSER(object);
	switch (property_id) {
	case WL_BT_FILE_CHOOSER_PROPERTY_TORRENT:
		obj->torrent = g_value_get_pointer(value);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_CTOR:
		obj->ctor = g_value_get_pointer(value);
		break;
	case WL_BT_FILE_CHOOSER_PROPERTY_PATH:
		if (!g_file_test(g_value_get_string(value), G_FILE_TEST_IS_DIR))	/* 目录不存在则不设置 */
			break;
		g_free(obj->default_path);
		obj->default_path = g_strdup(g_value_get_string(value));
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static GdkPixbuf *get_pixbuf_from_icon(GtkIconTheme * icon_theme,
									   GThemedIcon * icon, gint size)
{
	char **icon_names;
	GtkIconInfo *icon_info;
	GdkPixbuf *pixbuf;
	GError *error = NULL;

	g_object_get(icon, "names", &icon_names, NULL);

	icon_info =
		gtk_icon_theme_choose_icon(icon_theme, (const char **) icon_names,
								   size, 0);
	if (icon_info == NULL)
		return NULL;
	pixbuf = gtk_icon_info_load_icon(icon_info, &error);

	g_object_unref(icon_info);
	g_strfreev(icon_names);

	return pixbuf;
}

static GdkPixbuf *get_pixbuf_from_icon_name(const gchar * name, gint size)
{
	static GtkIconTheme *theme = NULL;
	GIcon *icon = g_themed_icon_new(name);
	if (icon == NULL)
		return NULL;
	if (theme == NULL) {
		theme = gtk_icon_theme_get_default();
	}
	GdkPixbuf *pixbuf =
		get_pixbuf_from_icon(theme, G_THEMED_ICON(icon), size);
	g_object_unref(icon);
	return pixbuf;
}

static gboolean wl_bt_file_chooser_close(GtkWidget * widget,
										 GdkEvent * event, gpointer data)
{
	/* 取消 */
	wl_bt_file_chooser_cancel(widget, data);

	return TRUE;
}


static wdl_set_file_dl_r(GtkTreeModel * model, tr_torrent * torrent,
						 GtkTreeIter * iter)
{
	if (gtk_tree_model_iter_has_child(model, iter)) {
		gint n = gtk_tree_model_iter_n_children(model, iter);
		gint i;
		for (i = 0; i < n; i++) {
			GtkTreeIter child_iter;
			gtk_tree_model_iter_nth_child(model, &child_iter, iter, i);
			wdl_set_file_dl_r(model, torrent, &child_iter);
		}
	} else {
		tr_file_index_t fi;
		gboolean dl;
		gchar *name = NULL;
		gtk_tree_model_get(model, iter, TREE_STORE_COL_INDEX, &fi,
						   TREE_STORE_COL_DL, &dl,
						   TREE_STORE_COL_NAME, &name, -1);
		tr_torrentSetFileDLs(torrent, &fi, 1, dl);
		g_free(name);
	}
}

static void wdl_set_all_file_dl(GtkTreeModel * model, tr_torrent * torrent)
{
	GtkTreeIter iter;
	if (gtk_tree_model_get_iter_first(model, &iter) && torrent != NULL) {
		wdl_set_file_dl_r(model, torrent, &iter);
	}
}

static inline void wl_bt_file_chooser_remove_torrent(WlBtFileChooser *
													 chooser)
{
	if (wl_bt_file_chooser_torrent_trash(chooser)) {
		move_file_to_trash(tr_ctorGetSourceFile(chooser->ctor));
	}
}

/*
 * 如果有文件被选中返回TRUE
 * 否则返回FALSE
 */
static gboolean isFileChoosed(WlBtFileChooser * chooser)
{
	GtkTreeModel *model =
		(GtkTreeModel *) gtk_builder_get_object(GTK_BUILDER(chooser),
												UI_TREESTORE);
	gboolean checked;
	gboolean inc;
	GtkTreeIter iter;

	gtk_tree_model_get_iter_first(model, &iter);
	gtk_tree_model_get(model, &iter, TREE_STORE_COL_DL, &checked,
					   TREE_STORE_COL_INC, &inc, -1);

	return inc || checked;
}

static void wl_bt_file_chooser_cancel(GtkWidget * button, gpointer data)
{
	WlBtFileChooser *chooser = data;
	GMainLoop *loop = chooser->loop;
	gtk_widget_hide(GTK_WIDGET(chooser->window));
	if (chooser->torrent)
		tr_torrentRemove(chooser->torrent, FALSE, 0);
	chooser->torrent = NULL;
	if (g_main_loop_is_running(loop))
		g_main_loop_quit(loop);
}

static void wl_bt_file_chooser_open(GtkWidget * button, gpointer data)
{
	WlBtFileChooser *chooser = data;
	GMainLoop *loop = chooser->loop;
	gtk_widget_hide(GTK_WIDGET(chooser->window));
	if (g_main_loop_is_running(loop))
		g_main_loop_quit(loop);

	if (isFileChoosed(chooser) == FALSE) {
		/* 没有一个文件被选中,相当于取消 TODO */
		wl_bt_file_chooser_cancel(button, data);
		return;
	}

	GtkTreeModel *model =
		(GtkTreeModel *) gtk_builder_get_object(GTK_BUILDER(chooser),
												UI_TREESTORE);
	wl_bt_file_chooser_remove_torrent(chooser);
	wdl_set_all_file_dl(model, chooser->torrent);
	tr_torrentSetDownloadDir(chooser->torrent,
							 wl_bt_file_chooser_get_path(chooser));
}

/* 将字节大小转化为可读的字符串形式 */
static const gchar *make_size_readable(guint64 size)
{
	static gchar string[20];
	if (size >= 1000 * 1000 * 1000) {	/* GB */
		g_snprintf(string, 20, "%.1f GB",
				   (gdouble) size / (1000.0 * 1000.0 * 1000.0));
	} else if (size >= 1000 * 1000) {
		g_snprintf(string, 20, "%.1f MB",
				   (gdouble) size / (1000.0 * 1000.0));
	} else if (size >= 1000) {
		g_snprintf(string, 20, "%.1f KB", (gdouble) size / (1000.0));
	} else {
		g_snprintf(string, 20, "%lu B", size);
	}
	return string;
}

/* 设置所有子节点的选中状态 */
static void wdl_set_all_child_dl(GtkTreeModel * model, GtkTreeIter * iter,
								 gboolean flag)
{
	if (gtk_tree_model_iter_has_child(model, iter)) {
		gint n = gtk_tree_model_iter_n_children(model, iter);
		gint i;
		for (i = 0; i < n; i++) {
			GtkTreeIter child_iter;
			gtk_tree_model_iter_nth_child(model, &child_iter, iter, i);
			gtk_tree_store_set(GTK_TREE_STORE(model), &child_iter,
							   TREE_STORE_COL_DL, flag, -1);
			wdl_set_all_child_dl(model, &child_iter, TRUE);
		}
	}
}

/*
 * 如果所有子文件都被选中，则返回0
 * 部分选中返回1
 * 都没选中返回2
 */
static gint wdl_all_child_toggled(GtkTreeModel * model, GtkTreeIter * iter)
{
	gint n = gtk_tree_model_iter_n_children(model, iter);
	gint s = n;
	gint i;
	for (i = 0; i < n; i++) {
		GtkTreeIter child_iter;
		gboolean toggled;
		gtk_tree_model_iter_nth_child(model, &child_iter, iter, i);
		gtk_tree_model_get(model, &child_iter, TREE_STORE_COL_DL, &toggled,
						   -1);
		if (!toggled)
			s--;
	}

	if (s == 0)
		return 2;
	else if (s == n)
		return 0;
	return 1;
}

/* 递归 */
static void wdl_update_dl_r(GtkTreeModel * model, GtkTreeIter * iter)
{
	if (gtk_tree_model_iter_has_child(model, iter)) {
		gint n = gtk_tree_model_iter_n_children(model, iter);
		gint i;
		guint64 len = 0;
		gboolean flag;
		for (i = 0; i < n; i++) {
			GtkTreeIter child_iter;
			guint64 length;
			gtk_tree_model_iter_nth_child(model, &child_iter, iter, i);
			gtk_tree_model_get(model, &child_iter, TREE_STORE_COL_LENGTH,
							   &length, TREE_STORE_COL_DL, &flag, -1);
			if (flag)			/* 只计算选中文件的大小 */
				len += length;
			wdl_update_dl_r(model, &child_iter);
		}
		gint stat = wdl_all_child_toggled(model, iter);
		if (stat == 2)			/* 没有任何子节点选中 */
			gtk_tree_store_set(GTK_TREE_STORE(model), iter,
							   TREE_STORE_COL_DL, FALSE,
							   TREE_STORE_COL_INC, FALSE, -1);
		else if (stat == 0)		/* 所有子节点都选中 */
			gtk_tree_store_set(GTK_TREE_STORE(model), iter,
							   TREE_STORE_COL_DL, TRUE, TREE_STORE_COL_INC,
							   FALSE, -1);
		else					/* 部分字节点选中 */
			gtk_tree_store_set(GTK_TREE_STORE(model), iter,
							   TREE_STORE_COL_DL, FALSE,
							   TREE_STORE_COL_INC, TRUE, -1);
		gtk_tree_store_set(GTK_TREE_STORE(model), iter,
						   TREE_STORE_COL_LENGTH, len,
						   TREE_STORE_COL_SIZE, make_size_readable(len),
						   -1);
	}
}

/* 自顶向下更新子文件下载状态，目录的选中和大小 */
static void wdl_update_all_dl(GtkTreeModel * model)
{
	GtkTreeIter iter;
	if (!gtk_tree_model_get_iter_first(model, &iter))
		return;
	wdl_update_dl_r(model, &iter);
}

void cellrenderertoggle_toggled_cb(GtkCellRendererToggle * cell,
								   gchar * path_str, gpointer data)
{
	GtkTreeModel *model = (GtkTreeModel *) data;
	GtkTreePath *path = gtk_tree_path_new_from_string(path_str);
	GtkTreeIter iter;
	gboolean toggle_item;


	/* get toggled iter */
	gtk_tree_model_get_iter(model, &iter, path);
	gtk_tree_model_get(model, &iter, TREE_STORE_COL_DL, &toggle_item, -1);

	/* do something with the value */
	toggle_item ^= 1;

	/* set new value */
	gtk_tree_store_set(GTK_TREE_STORE(model), &iter, TREE_STORE_COL_DL,
					   toggle_item, TREE_STORE_COL_INC, FALSE, -1);

	/* 选中获取取消所有子对象 */
	wdl_set_all_child_dl(model, &iter, toggle_item);
	/* 更新父节点状态 */
	wdl_update_all_dl(model);


	/* clean up */
	gtk_tree_path_free(path);
}

#include "icons.h"

static inline gboolean wl_bt_file_chooser_update(WlBtFileChooser * chooser)
{
	tr_ctor *ctor = chooser->ctor;
	gint err;
	gint duplicate;
	tr_torrent *torrent = tr_torrentNew(ctor, &err, &duplicate);
	chooser->torrent = torrent;
	GtkBuilder *ui = GTK_BUILDER(chooser);

	GtkTreeStore *file_tree =
		(GtkTreeStore *) gtk_builder_get_object(ui, UI_TREESTORE);
	GtkTreeView *tree_view =
		(GtkTreeView *) gtk_builder_get_object(ui, UI_TREEVIEW);
	/* 清空 */
	gtk_tree_store_clear(file_tree);

	GtkFileChooserButton *fc_button =
		(GtkFileChooserButton *) gtk_builder_get_object(ui,
														UI_TORRENT);
	GtkFileChooserButton *dc_button =
		(GtkFileChooserButton *) gtk_builder_get_object(ui,
														UI_FOLDER);
	GtkLabel *space_label =
		(GtkLabel *) gtk_builder_get_object(ui, UI_SPACE);

	GtkWidget *window =
		(GtkWidget *) gtk_builder_get_object(ui, UI_WINDOW);

	GtkWidget *cancel_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_CANCEL);

	if (torrent == NULL) {
		if (err == TR_PARSE_DUPLICATE) {
			wl_bt_file_chooser_show_duplicate(window,
											  tr_ctorGetSourceFile(ctor));
		} else {
			wl_bt_file_chooser_show_invalid(window,
											tr_ctorGetSourceFile(ctor));
		}
		return FALSE;
	}

	/* 种子文件和保存路径 */
	gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(fc_button),
								  tr_ctorGetSourceFile(ctor));
	gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(dc_button),
								  chooser->default_path);

	/* 磁盘空余 */
	GFile *file = g_file_new_for_path(tr_ctorGetSourceFile(ctor));
	GFileInfo *info = g_file_query_filesystem_info(file,
												   G_FILE_ATTRIBUTE_FILESYSTEM_FREE,
												   NULL, NULL);
	guint64 free_space = g_file_info_get_attribute_uint64(info,
														  G_FILE_ATTRIBUTE_FILESYSTEM_FREE);
	gtk_label_set_text(space_label, make_size_readable(free_space));
	g_object_unref(info);
	g_object_unref(file);

	/* 文件s */
	const tr_info *torrent_info = tr_torrentInfo(torrent);

	if (torrent_info->isMultifile) {	/* 多文件，有根目录 */
		/* 根目录 */
		GtkTreeIter root_iter;
		gtk_tree_store_append(file_tree, &root_iter, NULL);
		gtk_tree_store_set(file_tree, &root_iter,
						   TREE_STORE_COL_ICON,
						   get_pixbuf_from_icon_name(ICON_FOLDER,
													 TREEVIEW_ICON_SIZE),
						   TREE_STORE_COL_NAME, torrent_info->originalName,
						   TREE_STORE_COL_SIZE,
						   make_size_readable(torrent_info->totalSize),
						   TREE_STORE_COL_DL, TRUE, -1);
		gint i;
		/* show files in a tree view */
		for (i = 0; i < torrent_info->fileCount; i++) {
			const tr_file *torrent_file = &torrent_info->files[i];
			gchar **paths = g_strsplit(torrent_file->name, "/", -1);
			GtkTreeIter iter;
			memcpy(&iter, &root_iter, sizeof(GtkTreeIter));
			gint j;
			/* 扫描目录 */
			for (j = 0; paths[j + 1] != NULL; j++) {
				gchar *name = NULL;
				gtk_tree_model_get(GTK_TREE_MODEL(file_tree), &iter,
								   TREE_STORE_COL_NAME, &name, -1);
				if (g_strcmp0(name, paths[j]) == 0) {
					/* 当前路径已经存在，查找或者创建子路径 */
					gint n =
						gtk_tree_model_iter_n_children(GTK_TREE_MODEL
													   (file_tree), &iter);
					gint k;
					for (k = 0; k < n; k++) {
						GtkTreeIter child_iter;
						gtk_tree_model_iter_nth_child(GTK_TREE_MODEL
													  (file_tree),
													  &child_iter, &iter,
													  k);
						gchar *child_name = NULL;
						gtk_tree_model_get(GTK_TREE_MODEL(file_tree),
										   &child_iter,
										   TREE_STORE_COL_NAME,
										   &child_name, -1);
						if (g_strcmp0(child_name, paths[j + 1]) == 0) {
							memcpy(&iter, &child_iter,
								   sizeof(GtkTreeIter));
							g_free(child_name);
							break;
						}
						g_free(child_name);
					}
					if (k == n) {	/* 未找到子路径 */
						gtk_tree_store_append(file_tree, &iter, &iter);
						gtk_tree_store_set(file_tree, &iter,
										   TREE_STORE_COL_ICON,
										   get_pixbuf_from_icon_name
										   (ICON_FOLDER,
											TREEVIEW_ICON_SIZE),
										   TREE_STORE_COL_NAME,
										   paths[j + 1], TREE_STORE_COL_DL,
										   TRUE, TREE_STORE_COL_LENGTH, 0,
										   -1);
					}
				} else {
					g_error("%s\n%s", name, paths[j]);
				}
				g_free(name);
			}
			gtk_tree_store_set(file_tree, &iter,
							   TREE_STORE_COL_ICON,
							   wdl_get_pixbuf_from_filename(paths[j],
															GTK_ICON_SIZE_MENU),
							   TREE_STORE_COL_NAME, paths[j],
							   TREE_STORE_COL_SIZE,
							   make_size_readable(torrent_file->length),
							   TREE_STORE_COL_DL, TRUE,
							   TREE_STORE_COL_INDEX,
							   i,
							   TREE_STORE_COL_LENGTH, torrent_file->length,
							   -1);
			g_strfreev(paths);
		}
	} else {					/* 单文件种子 */
		GtkTreeIter root_iter;
		gtk_tree_store_append(file_tree, &root_iter, NULL);
		tr_file *file = &torrent_info->files[0];
		gtk_tree_store_set(file_tree, &root_iter,
						   TREE_STORE_COL_ICON,
						   wdl_get_pixbuf_from_filename(file->name,
														GTK_ICON_SIZE_MENU),
						   TREE_STORE_COL_NAME, file->name,
						   TREE_STORE_COL_SIZE,
						   make_size_readable(file->length),
						   TREE_STORE_COL_DL, TRUE, -1);
	}
	/* 第一次主要更新目录大小 */
	wdl_update_all_dl(GTK_TREE_MODEL(file_tree));

	/* expand all */
	gtk_tree_view_expand_all(tree_view);
	return TRUE;
}

static inline void wl_bt_file_chooser_show_invalid(GtkWidget * window,
												   const gchar * name)
{
	GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window),
											   GTK_DIALOG_MODAL |
											   GTK_DIALOG_DESTROY_WITH_PARENT,
											   GTK_MESSAGE_ERROR,
											   GTK_BUTTONS_OK,
											   "Invalid torrent file!");
	gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog),
											 "%s", name);
	gtk_dialog_run(GTK_DIALOG(dialog));
	gtk_widget_destroy(dialog);
}

static inline void wl_bt_file_chooser_show_duplicate(GtkWidget * window,
													 const gchar * name)
{
	GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window),
											   GTK_DIALOG_MODAL |
											   GTK_DIALOG_DESTROY_WITH_PARENT,
											   GTK_MESSAGE_WARNING,
											   GTK_BUTTONS_OK,
											   "Couldn't add duplicate torrent!");
	gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog),
											 "%s", name);
	gtk_dialog_run(GTK_DIALOG(dialog));
	gtk_widget_destroy(dialog);
}

static void wl_bt_file_chooser_set(GtkFileChooserButton * button,
								   gpointer data)
{
	WlBtFileChooser *chooser = data;
	gchar *path = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(button));
	tr_torrent *orig = chooser->torrent;
	const gchar *orig_file = tr_ctorGetSourceFile(chooser->ctor);
	if (g_strcmp0(orig_file, path) == 0) {	/* 没有改变 */
		g_free(path);
		return;
	}
	if (tr_ctorSetMetainfoFromFile(chooser->ctor, path)) {	/* 无效的文件 */
		wl_bt_file_chooser_show_invalid(NULL, path);
		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(button), orig_file);
	} else if (wl_bt_file_chooser_update(chooser) == FALSE) {
		gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(button), orig_file);
	}
	tr_torrentRemove(orig, FALSE, NULL);
	g_free(path);
}

static void move_file_to_trash(const gchar * path)
{
	GFile *file = g_file_new_for_path(path);
	g_file_trash(file, NULL, NULL);
	g_object_unref(file);
}

static inline gboolean wl_bt_file_chooser_torrent_trash(WlBtFileChooser *
														chooser)
{
	GtkWidget *trash_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_TRASH);
	return gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(trash_button));
}

/**********************************************************
 * PUBLIC
 **********************************************************/
WlBtFileChooser *wl_bt_file_chooser_new(tr_ctor * ctor)
{
	WlBtFileChooser *chooser =
		(WlBtFileChooser *) g_object_new(WL_TYPE_BT_FILE_CHOOSER, "ctor",
										 ctor, NULL);

	return chooser;
}

void wl_bt_file_chooser_set_download_path(WlBtFileChooser * chooser,
										  const gchar * path)
{
	g_return_if_fail(WL_IS_BT_FILE_CHOOSER(chooser));
	g_object_set(G_OBJECT(chooser), "path", path, NULL);
}

tr_torrent *wl_bt_file_chooser_run(WlBtFileChooser * chooser,
								   const gchar * path)
{
	g_return_val_if_fail(WL_IS_BT_FILE_CHOOSER(chooser)
						 && path != NULL, FALSE);
	GtkWidget *window = chooser->window;
	GtkWidget *open_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_OPEN);
	GtkWidget *cancel_button =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_CANCEL);
	GtkWidget *file_chooser =
		(GtkWidget *) gtk_builder_get_object(GTK_BUILDER(chooser),
											 UI_TORRENT);

	if (tr_ctorSetMetainfoFromFile(chooser->ctor, path)) {	/* 无效的文件 */
		wl_bt_file_chooser_show_invalid(window, path);
		return NULL;
	} else if (wl_bt_file_chooser_update(chooser) == FALSE) {
		return NULL;
	}

	gtk_widget_show_all(window);

	GMainLoop *loop = g_main_loop_new(NULL, FALSE);
	chooser->loop = loop;

	/* connect signals */
	gulong delete_handler =
		g_signal_connect(G_OBJECT(window), "delete-event",
						 G_CALLBACK(wl_bt_file_chooser_close), chooser);
	gulong open_handler =
		g_signal_connect(G_OBJECT(open_button), "clicked",
						 G_CALLBACK(wl_bt_file_chooser_open), chooser);
	gulong cancel_handler =
		g_signal_connect(G_OBJECT(cancel_button), "clicked",
						 G_CALLBACK(wl_bt_file_chooser_cancel), chooser);

	gulong file_set_handler =
		g_signal_connect(G_OBJECT(file_chooser), "file-set",
						 G_CALLBACK(wl_bt_file_chooser_set), chooser);

	g_main_loop_run(loop);
	g_main_loop_unref(loop);
	/* disconnect */
	g_signal_handler_disconnect(window, delete_handler);
	g_signal_handler_disconnect(open_button, open_handler);
	g_signal_handler_disconnect(cancel_button, cancel_handler);
	g_signal_handler_disconnect(file_chooser, file_set_handler);

	return chooser->torrent;
}

const gchar *wl_bt_file_chooser_get_path(WlBtFileChooser * chooser)
{
	g_return_val_if_fail(WL_IS_BT_FILE_CHOOSER(chooser), NULL);
	GtkFileChooserButton *dc_button = (GtkFileChooserButton *)
		gtk_builder_get_object(GTK_BUILDER(chooser),
							   UI_FOLDER);
	static gchar *filename = NULL;
	if (filename) {
		g_free(filename);
		filename = NULL;
	}
	filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dc_button));
	return filename;
}

/*
 * @description 获取种子元数据文件的路径
 */
const gchar *wl_bt_file_chooser_get_torrent_file(WlBtFileChooser * chooser)
{
	g_return_val_if_fail(WL_IS_BT_FILE_CHOOSER(chooser), NULL);
	return tr_ctorGetSourceFile(chooser->ctor);
}

gboolean wl_bt_file_chooser_auto_start(WlBtFileChooser * chooser)
{
	g_return_val_if_fail(WL_IS_BT_FILE_CHOOSER(chooser), FALSE);
	GtkToggleButton *start_button =
		(GtkToggleButton *) gtk_builder_get_object(GTK_BUILDER(chooser),
												   UI_START);
	return gtk_toggle_button_get_active(start_button);
}
